<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>üåê SAR Network Graph - Visualisation Interactive</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'SF Mono', 'Consolas', 'Monaco', monospace;
      background: #000000;
      color: #00ff00;
      overflow: hidden;
      height: 100vh;
    }

    .network-container {
      display: grid;
      grid-template-rows: 60px 1fr 50px;
      height: 100vh;
    }

    /* Header */
    .header {
      background: linear-gradient(180deg, #0a0a0a 0%, #000000 100%);
      border-bottom: 2px solid #00ff00;
      padding: 0 30px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      box-shadow: 0 4px 20px rgba(0, 255, 0, 0.3);
    }

    .header-title {
      font-size: 18px;
      font-weight: bold;
      color: #00ff00;
      text-shadow: 0 0 10px #00ff00;
      letter-spacing: 2px;
    }

    .header-controls {
      display: flex;
      gap: 15px;
    }

    .control-btn {
      background: rgba(0, 255, 0, 0.1);
      border: 1px solid #00ff00;
      color: #00ff00;
      padding: 8px 16px;
      font-family: inherit;
      font-size: 11px;
      cursor: pointer;
      border-radius: 4px;
      transition: all 0.3s;
      text-transform: uppercase;
      letter-spacing: 1px;
    }

    .control-btn:hover {
      background: rgba(0, 255, 0, 0.3);
      box-shadow: 0 0 15px rgba(0, 255, 0, 0.5);
    }

    .control-btn.active {
      background: rgba(0, 255, 0, 0.3);
      border-width: 2px;
    }

    /* Main Canvas */
    .canvas-container {
      position: relative;
      background: radial-gradient(circle at center, rgba(0, 255, 0, 0.05) 0%, transparent 70%);
      overflow: hidden;
    }

    #networkCanvas {
      width: 100%;
      height: 100%;
      cursor: grab;
    }

    #networkCanvas:active {
      cursor: grabbing;
    }

    /* Legend */
    .legend {
      position: absolute;
      top: 20px;
      right: 20px;
      background: rgba(0, 0, 0, 0.9);
      border: 2px solid #00ff00;
      border-radius: 8px;
      padding: 15px;
      font-size: 11px;
    }

    .legend-title {
      font-size: 12px;
      font-weight: bold;
      color: #00ff00;
      margin-bottom: 10px;
      text-transform: uppercase;
      letter-spacing: 1px;
    }

    .legend-item {
      display: flex;
      align-items: center;
      gap: 10px;
      margin: 8px 0;
    }

    .legend-dot {
      width: 14px;
      height: 14px;
      border-radius: 50%;
      box-shadow: 0 0 8px;
    }

    .legend-dot.route {
      background: #00ff00;
      box-shadow: 0 0 8px #00ff00;
    }

    .legend-dot.database {
      background: #ffff00;
      box-shadow: 0 0 8px #ffff00;
    }

    .legend-dot.external {
      background: #0096ff;
      box-shadow: 0 0 8px #0096ff;
    }

    .legend-dot.selected {
      background: #ff00ff;
      box-shadow: 0 0 8px #ff00ff;
    }

    /* Node Details Panel */
    .details-panel {
      position: absolute;
      left: 20px;
      top: 20px;
      width: 350px;
      max-height: calc(100% - 40px);
      background: rgba(0, 0, 0, 0.95);
      border: 2px solid #00ff00;
      border-radius: 8px;
      padding: 20px;
      overflow-y: auto;
      display: none;
      animation: slideIn 0.3s ease;
    }

    @keyframes slideIn {
      from {
        transform: translateX(-20px);
        opacity: 0;
      }
      to {
        transform: translateX(0);
        opacity: 1;
      }
    }

    .details-header {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      margin-bottom: 15px;
      padding-bottom: 10px;
      border-bottom: 1px solid #00ff00;
    }

    .details-title {
      font-size: 14px;
      font-weight: bold;
      color: #00ff00;
    }

    .close-btn {
      background: transparent;
      border: none;
      color: #ff0000;
      font-size: 18px;
      cursor: pointer;
      padding: 0;
      line-height: 1;
    }

    .detail-section {
      margin: 15px 0;
    }

    .detail-label {
      font-size: 10px;
      color: #666;
      text-transform: uppercase;
      margin-bottom: 5px;
    }

    .detail-value {
      font-size: 12px;
      color: #00ff00;
      line-height: 1.6;
    }

    .connection-list {
      list-style: none;
      margin: 5px 0;
    }

    .connection-item {
      padding: 5px 8px;
      margin: 3px 0;
      background: rgba(0, 255, 0, 0.1);
      border-left: 2px solid #00ff00;
      font-size: 10px;
      cursor: pointer;
      transition: all 0.2s;
    }

    .connection-item:hover {
      background: rgba(0, 255, 0, 0.2);
      padding-left: 12px;
    }

    /* Footer Stats */
    .footer {
      background: #000000;
      border-top: 2px solid #00ff00;
      padding: 0 30px;
      display: flex;
      justify-content: space-around;
      align-items: center;
    }

    .stat-box {
      text-align: center;
      font-size: 11px;
    }

    .stat-value {
      font-size: 20px;
      font-weight: bold;
      color: #00ff00;
    }

    .stat-label {
      font-size: 9px;
      color: #666;
      text-transform: uppercase;
    }

    /* Scrollbar */
    ::-webkit-scrollbar {
      width: 6px;
    }

    ::-webkit-scrollbar-track {
      background: #0a0a0a;
    }

    ::-webkit-scrollbar-thumb {
      background: #00ff00;
      border-radius: 3px;
    }

    /* Loading */
    .loading {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 18px;
      color: #00ff00;
      text-align: center;
    }

    .loading::after {
      content: '...';
      animation: dots 1.5s infinite;
    }

    @keyframes dots {
      0%, 20% { content: '.'; }
      40% { content: '..'; }
      60%, 100% { content: '...'; }
    }
  </style>
</head>
<body>
  <div class="network-container">
    <!-- Header -->
    <div class="header">
      <div class="header-title">üåê SAR NETWORK GRAPH - INTERACTIVE VISUALIZATION</div>
      <div class="header-controls">
        <button class="control-btn" onclick="resetView()">üîÑ Reset View</button>
        <button class="control-btn" onclick="togglePhysics()">‚ö° Physics</button>
        <button class="control-btn" onclick="exportGraph()">üíæ Export</button>
        <button class="control-btn" onclick="showAllRoutes()">üìã All Routes</button>
      </div>
    </div>

    <!-- Main Canvas -->
    <div class="canvas-container">
      <canvas id="networkCanvas"></canvas>

      <!-- Legend -->
      <div class="legend">
        <div class="legend-title">L√©gende</div>
        <div class="legend-item">
          <div class="legend-dot route"></div>
          <span>Routes API (69)</span>
        </div>
        <div class="legend-item">
          <div class="legend-dot database"></div>
          <span>Tables BD (8)</span>
        </div>
        <div class="legend-item">
          <div class="legend-dot external"></div>
          <span>Services Externes (7)</span>
        </div>
        <div class="legend-item">
          <div class="legend-dot selected"></div>
          <span>S√©lectionn√©</span>
        </div>
      </div>

      <!-- Details Panel -->
      <div class="details-panel" id="detailsPanel">
        <div class="details-header">
          <div class="details-title" id="detailsTitle">Node Details</div>
          <button class="close-btn" onclick="closeDetails()">‚úï</button>
        </div>
        <div id="detailsContent">
          <!-- Details will be injected here -->
        </div>
      </div>

      <!-- Loading -->
      <div class="loading" id="loading">Loading Network Graph</div>
    </div>

    <!-- Footer Stats -->
    <div class="footer">
      <div class="stat-box">
        <div class="stat-value" id="totalNodes">0</div>
        <div class="stat-label">Total Nodes</div>
      </div>
      <div class="stat-box">
        <div class="stat-value" id="totalEdges">0</div>
        <div class="stat-label">Connections</div>
      </div>
      <div class="stat-box">
        <div class="stat-value" id="selectedNode">None</div>
        <div class="stat-label">Selected</div>
      </div>
      <div class="stat-box">
        <div class="stat-value" id="zoomLevel">100%</div>
        <div class="stat-label">Zoom</div>
      </div>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('networkCanvas')
    const ctx = canvas.getContext('2d')

    // Network data
    const nodes = []
    const edges = []
    let selectedNode = null
    let hoveredNode = null

    // Camera controls
    let camera = {
      x: 0,
      y: 0,
      zoom: 1,
      isDragging: false,
      dragStart: { x: 0, y: 0 }
    }

    // Physics simulation
    let physicsEnabled = true
    const REPULSION_FORCE = 5000
    const SPRING_FORCE = 0.01
    const DAMPING = 0.9
    const MIN_DISTANCE = 100

    // Initialize canvas
    function initCanvas() {
      canvas.width = canvas.offsetWidth
      canvas.height = canvas.offsetHeight
    }

    // Load network data
    async function loadNetworkData() {
      try {
        const response = await fetch('/deep-recon-report.json')
        const report = await response.json()

        // Add route nodes
        report.routes.forEach((route, i) => {
          const angle = (i / report.routes.length) * Math.PI * 2
          const radius = 300

          nodes.push({
            id: route.path,
            label: route.path.split('/').pop() || 'root',
            type: 'route',
            x: Math.cos(angle) * radius,
            y: Math.sin(angle) * radius,
            vx: 0,
            vy: 0,
            radius: 8,
            color: '#00ff00',
            data: route
          })
        })

        // Add database nodes
        report.database.tables.forEach((table, i) => {
          const angle = (i / report.database.tables.length) * Math.PI * 2
          const radius = 500

          nodes.push({
            id: 'db_' + table,
            label: table,
            type: 'database',
            x: Math.cos(angle) * radius,
            y: Math.sin(angle) * radius,
            vx: 0,
            vy: 0,
            radius: 12,
            color: '#ffff00',
            data: { table }
          })
        })

        // Add external service nodes
        report.external_services.forEach((service, i) => {
          const angle = (i / report.external_services.length) * Math.PI * 2
          const radius = 600

          nodes.push({
            id: 'ext_' + service.name,
            label: service.name,
            type: 'external',
            x: Math.cos(angle) * radius,
            y: Math.sin(angle) * radius,
            vx: 0,
            vy: 0,
            radius: 10,
            color: '#0096ff',
            data: service
          })
        })

        // Create edges (connections)
        report.routes.forEach(route => {
          // Connect routes to databases
          if (route.usesSupabase) {
            report.database.tables.forEach(table => {
              if (route.file.toLowerCase().includes(table.toLowerCase()) ||
                  route.path.toLowerCase().includes(table.toLowerCase())) {
                edges.push({
                  from: route.path,
                  to: 'db_' + table,
                  type: 'database'
                })
              }
            })
          }

          // Connect routes to external services
          route.externalAPIs.forEach(api => {
            report.external_services.forEach(service => {
              if (api.toLowerCase().includes(service.name.toLowerCase())) {
                edges.push({
                  from: route.path,
                  to: 'ext_' + service.name,
                  type: 'external'
                })
              }
            })
          })
        })

        // Update stats
        document.getElementById('totalNodes').textContent = nodes.length
        document.getElementById('totalEdges').textContent = edges.length

        // Hide loading
        document.getElementById('loading').style.display = 'none'

        // Center camera
        camera.x = canvas.width / 2
        camera.y = canvas.height / 2

        // Start animation
        animate()
      } catch (error) {
        console.error('Error loading network data:', error)
        document.getElementById('loading').textContent = 'Error loading data'
      }
    }

    // Physics simulation
    function updatePhysics() {
      if (!physicsEnabled) return

      // Repulsion between nodes
      for (let i = 0; i < nodes.length; i++) {
        for (let j = i + 1; j < nodes.length; j++) {
          const node1 = nodes[i]
          const node2 = nodes[j]

          const dx = node2.x - node1.x
          const dy = node2.y - node1.y
          const dist = Math.sqrt(dx * dx + dy * dy) || 1

          if (dist < MIN_DISTANCE * 2) {
            const force = REPULSION_FORCE / (dist * dist)
            const fx = (dx / dist) * force
            const fy = (dy / dist) * force

            node1.vx -= fx
            node1.vy -= fy
            node2.vx += fx
            node2.vy += fy
          }
        }
      }

      // Spring force for connected nodes
      edges.forEach(edge => {
        const node1 = nodes.find(n => n.id === edge.from)
        const node2 = nodes.find(n => n.id === edge.to)

        if (node1 && node2) {
          const dx = node2.x - node1.x
          const dy = node2.y - node1.y
          const dist = Math.sqrt(dx * dx + dy * dy) || 1

          const targetDist = 200
          const force = (dist - targetDist) * SPRING_FORCE

          const fx = (dx / dist) * force
          const fy = (dy / dist) * force

          node1.vx += fx
          node1.vy += fy
          node2.vx -= fx
          node2.vy -= fy
        }
      })

      // Update positions
      nodes.forEach(node => {
        if (node !== selectedNode) {
          node.x += node.vx
          node.y += node.vy
          node.vx *= DAMPING
          node.vy *= DAMPING
        }
      })
    }

    // Draw network
    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height)

      ctx.save()
      ctx.translate(camera.x, camera.y)
      ctx.scale(camera.zoom, camera.zoom)

      // Draw edges
      ctx.lineWidth = 1
      edges.forEach(edge => {
        const node1 = nodes.find(n => n.id === edge.from)
        const node2 = nodes.find(n => n.id === edge.to)

        if (node1 && node2) {
          ctx.beginPath()
          ctx.moveTo(node1.x, node1.y)
          ctx.lineTo(node2.x, node2.y)

          if (edge.type === 'database') {
            ctx.strokeStyle = 'rgba(255, 255, 0, 0.2)'
          } else if (edge.type === 'external') {
            ctx.strokeStyle = 'rgba(0, 150, 255, 0.2)'
          } else {
            ctx.strokeStyle = 'rgba(0, 255, 0, 0.2)'
          }

          ctx.stroke()
        }
      })

      // Draw nodes
      nodes.forEach(node => {
        const isSelected = node === selectedNode
        const isHovered = node === hoveredNode

        // Glow effect
        if (isSelected || isHovered) {
          ctx.beginPath()
          ctx.arc(node.x, node.y, node.radius + 10, 0, Math.PI * 2)
          ctx.fillStyle = isSelected ? 'rgba(255, 0, 255, 0.3)' : 'rgba(255, 255, 255, 0.2)'
          ctx.fill()
        }

        // Node circle
        ctx.beginPath()
        ctx.arc(node.x, node.y, node.radius, 0, Math.PI * 2)
        ctx.fillStyle = isSelected ? '#ff00ff' : node.color
        ctx.fill()
        ctx.shadowBlur = 10
        ctx.shadowColor = isSelected ? '#ff00ff' : node.color

        // Border
        ctx.strokeStyle = '#000'
        ctx.lineWidth = 2
        ctx.stroke()
        ctx.shadowBlur = 0

        // Label
        if (camera.zoom > 0.5) {
          ctx.fillStyle = node.color
          ctx.font = '10px monospace'
          ctx.textAlign = 'center'
          ctx.fillText(node.label, node.x, node.y + node.radius + 15)
        }
      })

      ctx.restore()
    }

    // Animation loop
    function animate() {
      updatePhysics()
      draw()
      requestAnimationFrame(animate)
    }

    // Mouse events
    function getMousePos(e) {
      const rect = canvas.getBoundingClientRect()
      return {
        x: (e.clientX - rect.left - camera.x) / camera.zoom,
        y: (e.clientY - rect.top - camera.y) / camera.zoom
      }
    }

    function getNodeAtPos(x, y) {
      return nodes.find(node => {
        const dx = node.x - x
        const dy = node.y - y
        return Math.sqrt(dx * dx + dy * dy) < node.radius + 5
      })
    }

    canvas.addEventListener('mousedown', (e) => {
      const pos = getMousePos(e)
      const node = getNodeAtPos(pos.x, pos.y)

      if (node) {
        selectedNode = node
        showNodeDetails(node)
      } else {
        camera.isDragging = true
        camera.dragStart = { x: e.clientX - camera.x, y: e.clientY - camera.y }
      }
    })

    canvas.addEventListener('mousemove', (e) => {
      if (camera.isDragging) {
        camera.x = e.clientX - camera.dragStart.x
        camera.y = e.clientY - camera.dragStart.y
      } else {
        const pos = getMousePos(e)
        hoveredNode = getNodeAtPos(pos.x, pos.y)
        canvas.style.cursor = hoveredNode ? 'pointer' : 'grab'
      }
    })

    canvas.addEventListener('mouseup', () => {
      camera.isDragging = false
    })

    canvas.addEventListener('wheel', (e) => {
      e.preventDefault()
      const delta = e.deltaY > 0 ? 0.9 : 1.1
      camera.zoom *= delta
      camera.zoom = Math.max(0.1, Math.min(camera.zoom, 3))

      document.getElementById('zoomLevel').textContent = Math.round(camera.zoom * 100) + '%'
    })

    // Show node details
    function showNodeDetails(node) {
      const panel = document.getElementById('detailsPanel')
      const title = document.getElementById('detailsTitle')
      const content = document.getElementById('detailsContent')

      title.textContent = node.label

      let html = `
        <div class="detail-section">
          <div class="detail-label">Type</div>
          <div class="detail-value">${node.type.toUpperCase()}</div>
        </div>
        <div class="detail-section">
          <div class="detail-label">ID</div>
          <div class="detail-value">${node.id}</div>
        </div>
      `

      if (node.type === 'route') {
        html += `
          <div class="detail-section">
            <div class="detail-label">Methods</div>
            <div class="detail-value">${node.data.methods.join(', ')}</div>
          </div>
          <div class="detail-section">
            <div class="detail-label">File</div>
            <div class="detail-value">${node.data.file}</div>
          </div>
          <div class="detail-section">
            <div class="detail-label">Lines of Code</div>
            <div class="detail-value">${node.data.linesOfCode}</div>
          </div>
        `

        // Connected nodes
        const connectedEdges = edges.filter(e => e.from === node.id)
        if (connectedEdges.length > 0) {
          html += `
            <div class="detail-section">
              <div class="detail-label">Connected To</div>
              <ul class="connection-list">
                ${connectedEdges.map(edge => {
                  const targetNode = nodes.find(n => n.id === edge.to)
                  return `<li class="connection-item" onclick="selectNodeById('${edge.to}')">${targetNode ? targetNode.label : edge.to}</li>`
                }).join('')}
              </ul>
            </div>
          `
        }
      }

      content.innerHTML = html
      panel.style.display = 'block'

      document.getElementById('selectedNode').textContent = node.label
    }

    function closeDetails() {
      document.getElementById('detailsPanel').style.display = 'none'
      selectedNode = null
      document.getElementById('selectedNode').textContent = 'None'
    }

    function selectNodeById(id) {
      const node = nodes.find(n => n.id === id)
      if (node) {
        selectedNode = node
        showNodeDetails(node)

        // Center on node
        camera.x = canvas.width / 2 - node.x * camera.zoom
        camera.y = canvas.height / 2 - node.y * camera.zoom
      }
    }

    // Control functions
    function resetView() {
      camera.x = canvas.width / 2
      camera.y = canvas.height / 2
      camera.zoom = 1
      document.getElementById('zoomLevel').textContent = '100%'
    }

    function togglePhysics() {
      physicsEnabled = !physicsEnabled
      const btn = event.target
      btn.classList.toggle('active')
      btn.textContent = physicsEnabled ? '‚ö° Physics ON' : '‚ö° Physics OFF'
    }

    function exportGraph() {
      const data = {
        nodes: nodes.map(n => ({
          id: n.id,
          label: n.label,
          type: n.type
        })),
        edges: edges
      }

      const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' })
      const url = URL.createObjectURL(blob)
      const a = document.createElement('a')
      a.href = url
      a.download = 'sar-network-graph.json'
      a.click()
    }

    function showAllRoutes() {
      window.open('/control-panel-complete.html', '_blank')
    }

    // Initialize
    window.addEventListener('load', () => {
      initCanvas()
      loadNetworkData()
    })

    window.addEventListener('resize', () => {
      initCanvas()
    })
  </script>
</body>
</html>
