#!/usr/bin/env node
/**
 * üéØ Test R√©el de Techniques de Bypass
 * Teste les vraies techniques qui fonctionnent
 */

const BASE_URL = 'http://localhost:3000'

const COLORS = {
  reset: '\x1b[0m',
  red: '\x1b[31m',
  green: '\x1b[32m',
  yellow: '\x1b[33m',
  cyan: '\x1b[36m',
  magenta: '\x1b[35m',
}

const log = (color, msg) => console.log(`${COLORS[color]}${msg}${COLORS.reset}`)

// ============================================
// 1. IDOR Testing
// ============================================
async function testIDOR() {
  log('cyan', '\nüéØ Test 1: IDOR (Insecure Direct Object Reference)')
  log('yellow', '   Tentative d\'acc√®s aux demandes d\'autres clients...\n')

  const results = []
  const refs = ['SAR-LP-000001', 'SAR-LP-000002', 'SAR-LP-000003', 'SAR-LP-999999']

  for (const ref of refs) {
    try {
      const res = await fetch(`${BASE_URL}/api/applications/${ref}`)
      const data = await res.json()

      if (res.status === 200 && data.success) {
        log('red', `  üö® VULN√âRABLE: ${ref} - Accessible sans auth!`)
        log('yellow', `     Donn√©es: ${JSON.stringify(data).substring(0, 100)}...`)
        results.push({ vulnerable: true, ref, status: res.status })
      } else if (res.status === 401 || res.status === 403) {
        log('green', `  ‚úÖ Prot√©g√©: ${ref} - Auth requise (${res.status})`)
        results.push({ vulnerable: false, ref, status: res.status })
      } else if (res.status === 404) {
        log('cyan', `  ‚ÑπÔ∏è  ${ref} - N'existe pas (404)`)
        results.push({ vulnerable: false, ref, status: res.status })
      }
    } catch (error) {
      log('yellow', `  ‚ö†Ô∏è  ${ref} - Erreur: ${error.message}`)
    }
  }

  return results
}

// ============================================
// 2. SQL Injection dans Auth
// ============================================
async function testSQLInjection() {
  log('cyan', '\nüíâ Test 2: SQL Injection dans Authentication')
  log('yellow', '   Tentative de bypass avec payloads SQL...\n')

  const payloads = [
    {
      name: 'OR 1=1',
      email: "admin@example.com' OR '1'='1' --",
      password: 'nimportequoi',
    },
    {
      name: 'UNION SELECT',
      email: "admin' UNION SELECT * FROM users--",
      password: 'x',
    },
    {
      name: 'Comment bypass',
      email: 'admin@example.com\'/**/OR/**/1=1--',
      password: 'x',
    },
  ]

  const results = []

  for (const payload of payloads) {
    try {
      const res = await fetch(`${BASE_URL}/api/auth/login`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          email: payload.email,
          password: payload.password,
        }),
      })

      const data = await res.json()

      if (res.status === 200 && data.token) {
        log('red', `  üö® VULN√âRABLE: ${payload.name}`)
        log('red', `     Token re√ßu: ${data.token.substring(0, 50)}...`)
        results.push({ vulnerable: true, payload: payload.name })
      } else if (res.status === 400 || res.status === 401) {
        log('green', `  ‚úÖ Prot√©g√©: ${payload.name} - Bloqu√© (${res.status})`)
        results.push({ vulnerable: false, payload: payload.name })
      } else if (res.status === 404) {
        log('cyan', `  ‚ÑπÔ∏è  Route d'auth pas encore impl√©ment√©e`)
        break
      }
    } catch (error) {
      log('yellow', `  ‚ö†Ô∏è  ${payload.name} - Erreur: ${error.message}`)
    }
  }

  return results
}

// ============================================
// 3. Rate Limiting Bypass avec IP Spoofing
// ============================================
async function testRateLimitBypass() {
  log('cyan', '\n‚è±Ô∏è  Test 3: Rate Limiting Bypass (IP Spoofing)')
  log('yellow', '   Tentative de bypass avec X-Forwarded-For...\n')

  const results = []
  let successCount = 0

  for (let i = 0; i < 10; i++) {
    try {
      const res = await fetch(`${BASE_URL}/api/applications/submit`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'X-Forwarded-For': `192.168.1.${i}`, // IP diff√©rente √† chaque fois
        },
        body: JSON.stringify({
          origin: 'argentrapide',
          prenom: `Test${i}`,
          nom: 'User',
          courriel: `test${i}@bypass.com`,
          telephone: '5141234567',
          montant_demande: 100000,
        }),
      })

      if (res.status === 200) {
        successCount++
        log('cyan', `  ‚Üí Requ√™te ${i + 1}: Accept√©e (200)`)
      } else if (res.status === 429) {
        log('green', `  ‚úÖ Rate limit activ√© √† la requ√™te ${i + 1}`)
        results.push({ vulnerable: false, blockedAt: i + 1 })
        break
      } else {
        log('yellow', `  ‚Üí Requ√™te ${i + 1}: ${res.status}`)
      }
    } catch (error) {
      log('yellow', `  ‚ö†Ô∏è  Requ√™te ${i + 1} - Erreur: ${error.message}`)
    }
  }

  if (successCount === 10) {
    log('red', `  üö® VULN√âRABLE: 10 requ√™tes pass√©es avec IP spoofing!`)
    results.push({ vulnerable: true, requestsPassed: 10 })
  }

  return results
}

// ============================================
// 4. Path Traversal
// ============================================
async function testPathTraversal() {
  log('cyan', '\nüìÅ Test 4: Path Traversal')
  log('yellow', '   Tentative d\'acc√®s aux fichiers sensibles...\n')

  const paths = [
    '../../../.env.local',
    '../../../../.env.local',
    '../../../etc/passwd',
    '....//....//....//etc/passwd',
    '..%252F..%252F.env.local',
  ]

  const results = []

  for (const path of paths) {
    try {
      const res = await fetch(`${BASE_URL}/api/files?path=${encodeURIComponent(path)}`)

      if (res.status === 200) {
        const text = await res.text()
        if (text.includes('SUPABASE') || text.includes('root:') || text.includes('PASSWORD')) {
          log('red', `  üö® VULN√âRABLE: ${path}`)
          log('red', `     Contenu: ${text.substring(0, 100)}...`)
          results.push({ vulnerable: true, path })
        }
      } else if (res.status === 400 || res.status === 403) {
        log('green', `  ‚úÖ Prot√©g√©: ${path} - Bloqu√© (${res.status})`)
        results.push({ vulnerable: false, path })
      } else if (res.status === 404) {
        log('cyan', `  ‚ÑπÔ∏è  Route /api/files pas impl√©ment√©e`)
        break
      }
    } catch (error) {
      log('yellow', `  ‚ö†Ô∏è  ${path} - Erreur: ${error.message}`)
    }
  }

  return results
}

// ============================================
// 5. JWT Algorithm Confusion
// ============================================
async function testJWTBypass() {
  log('cyan', '\nüîë Test 5: JWT Algorithm Confusion')
  log('yellow', '   Tentative de bypass avec algo "none"...\n')

  const fakeJWTs = [
    {
      name: 'Algorithm: none',
      token:
        btoa(JSON.stringify({ alg: 'none', typ: 'JWT' })) +
        '.' +
        btoa(JSON.stringify({ sub: 'admin', role: 'admin', email: 'admin@example.com' })) +
        '.',
    },
    {
      name: 'Algorithm: HS256 with empty secret',
      token: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJhZG1pbiIsInJvbGUiOiJhZG1pbiJ9.',
    },
  ]

  const results = []

  for (const { name, token } of fakeJWTs) {
    try {
      const res = await fetch(`${BASE_URL}/api/admin/metrics/inspect`, {
        headers: { Authorization: `Bearer ${token}` },
      })

      if (res.status === 200) {
        log('red', `  üö® VULN√âRABLE: ${name}`)
        log('red', `     Acc√®s admin obtenu avec fake JWT!`)
        results.push({ vulnerable: true, technique: name })
      } else if (res.status === 401 || res.status === 403) {
        log('green', `  ‚úÖ Prot√©g√©: ${name} - Rejet√© (${res.status})`)
        results.push({ vulnerable: false, technique: name })
      } else if (res.status === 404) {
        log('cyan', `  ‚ÑπÔ∏è  Route admin pas impl√©ment√©e`)
        break
      }
    } catch (error) {
      log('yellow', `  ‚ö†Ô∏è  ${name} - Erreur: ${error.message}`)
    }
  }

  return results
}

// ============================================
// 6. OSINT Route sans Auth
// ============================================
async function testOSINTAccess() {
  log('cyan', '\nüîç Test 6: OSINT Routes sans Authentification')
  log('yellow', '   Test d\'acc√®s aux routes OSINT sensibles...\n')

  const routes = [
    '/api/osint/scan',
    '/api/osint/network-scan',
    '/api/osint/bypass-tests',
    '/api/osint/advanced',
  ]

  const results = []

  for (const route of routes) {
    try {
      // Test sans auth
      const res = await fetch(`${BASE_URL}${route}`)

      if (res.status === 200) {
        const data = await res.json()
        if (data.success) {
          log('red', `  üö® VULN√âRABLE: ${route}`)
          log('red', `     Donn√©es sensibles expos√©es sans auth!`)
          if (data.data) {
            log('yellow', `     Preview: ${JSON.stringify(data.data).substring(0, 150)}...`)
          }
          results.push({ vulnerable: true, route })
        }
      } else if (res.status === 401 || res.status === 403) {
        log('green', `  ‚úÖ Prot√©g√©: ${route} - Auth requise (${res.status})`)
        results.push({ vulnerable: false, route })
      } else if (res.status === 404 || res.status === 405) {
        log('cyan', `  ‚ÑπÔ∏è  ${route} - Non impl√©ment√© ou m√©thode incorrecte`)
        results.push({ vulnerable: false, route, note: 'not_implemented' })
      }
    } catch (error) {
      log('yellow', `  ‚ö†Ô∏è  ${route} - Erreur: ${error.message}`)
    }
  }

  return results
}

// ============================================
// MAIN
// ============================================
async function main() {
  log('magenta', '\n‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó')
  log('magenta', '‚ïë   üéØ TEST R√âEL DE TECHNIQUES DE BYPASS - R&D MODE       ‚ïë')
  log('magenta', '‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù')

  log('yellow', '\n‚ö†Ô∏è  AVERTISSEMENT: Tests de bypass en environnement local')
  log('yellow', '   Ces tests v√©rifient les vraies techniques d\'exploitation\n')

  const allResults = {
    idor: await testIDOR(),
    sqlInjection: await testSQLInjection(),
    rateLimitBypass: await testRateLimitBypass(),
    pathTraversal: await testPathTraversal(),
    jwtBypass: await testJWTBypass(),
    osintAccess: await testOSINTAccess(),
  }

  // R√©sum√©
  log('cyan', '\n‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê')
  log('cyan', 'üìä R√âSUM√â DES VULN√âRABILIT√âS')
  log('cyan', '‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n')

  const vulnerabilities = []

  Object.entries(allResults).forEach(([category, results]) => {
    const vulnCount = results.filter((r) => r.vulnerable).length
    if (vulnCount > 0) {
      vulnerabilities.push({ category, count: vulnCount })
    }
  })

  if (vulnerabilities.length > 0) {
    log('red', 'üö® VULN√âRABILIT√âS CRITIQUES D√âTECT√âES:\n')
    vulnerabilities.forEach(({ category, count }) => {
      log('red', `   ${category}: ${count} vuln√©rabilit√©(s)`)
    })

    log('yellow', '\nüí° ACTIONS REQUISES:')
    log('yellow', '   1. Lire BYPASS-TECHNIQUES-REAL.md pour comprendre')
    log('yellow', '   2. Appliquer les d√©fenses recommand√©es')
    log('yellow', '   3. Relancer ce test pour v√©rifier')
  } else {
    log('green', '\n‚úÖ Aucune vuln√©rabilit√© critique d√©tect√©e!')
    log('green', '   Votre syst√®me r√©siste aux techniques de bypass courantes.')
  }

  log('cyan', '\n‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n')
}

// Run
main().catch((error) => {
  log('red', `\n‚ùå Erreur: ${error.message}`)
  process.exit(1)
})
