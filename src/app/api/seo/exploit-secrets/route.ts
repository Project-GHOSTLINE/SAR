// API: SEO Secret Exploitation - Reveal Hidden SEO Techniques
// POST /api/seo/exploit-secrets - Deep SEO analysis & hidden technique detection

import { NextRequest, NextResponse } from 'next/server';
import { exec } from 'child_process';
import { promisify } from 'util';

const execAsync = promisify(exec);

export async function POST(request: NextRequest) {
  try {
    const { target } = await request.json();

    const results: any = {
      timestamp: new Date().toISOString(),
      target,
      secrets_found: [],
      hidden_pages: [],
      cloaking_detected: false,
      backlinks: [],
      competitor_analysis: {},
      keyword_gaps: [],
      technical_seo: {},
      black_hat_techniques: []
    };

    // 1. Find hidden pages (robots.txt, sitemap.xml, etc.)
    results.hidden_pages = await findHiddenPages(target);

    // 2. Detect cloaking (different content for bots vs users)
    results.cloaking_detected = await detectCloaking(target);

    // 3. Extract all meta tags and hidden content
    results.secrets_found.push(...await extractMetaSecrets(target));

    // 4. Find hidden backlinks
    results.backlinks = await findBacklinks(target);

    // 5. Discover keyword stuffing and hidden text
    results.black_hat_techniques.push(...await detectBlackHat(target));

    // 6. Technical SEO analysis
    results.technical_seo = await analyzeTechnicalSEO(target);

    // 7. Find competitor keywords
    results.keyword_gaps = await findKeywordGaps(target);

    // 8. Discover hidden redirects
    results.secrets_found.push(...await findHiddenRedirects(target));

    // 9. Extract structured data secrets
    results.secrets_found.push(...await extractStructuredData(target));

    // 10. Find hidden internal linking structure
    results.secrets_found.push(...await analyzeInternalLinks(target));

    return NextResponse.json({
      success: true,
      results
    });

  } catch (error: any) {
    return NextResponse.json(
      { success: false, error: error.message },
      { status: 500 }
    );
  }
}

// Find hidden pages
async function findHiddenPages(target: string): Promise<any[]> {
  const pages: any[] = [];

  try {
    // Check robots.txt
    const { stdout: robots } = await execAsync(
      `curl -sL "https://${target}/robots.txt" --max-time 5`,
      { timeout: 6000 }
    );

    if (robots && !robots.includes('404') && !robots.includes('Not Found')) {
      const disallowMatches = robots.match(/Disallow:\s*(.+)/gi);
      if (disallowMatches) {
        disallowMatches.forEach(match => {
          const path = match.replace(/Disallow:\s*/i, '').trim();
          if (path && path !== '/') {
            pages.push({
              type: 'Disallowed in robots.txt',
              url: `https://${target}${path}`,
              path,
              severity: 'HIGH',
              description: 'Hidden from search engines but may contain valuable content'
            });
          }
        });
      }

      // Check for sitemap
      const sitemapMatches = robots.match(/Sitemap:\s*(.+)/gi);
      if (sitemapMatches) {
        sitemapMatches.forEach(match => {
          const url = match.replace(/Sitemap:\s*/i, '').trim();
          pages.push({
            type: 'Sitemap found',
            url,
            severity: 'INFO',
            description: 'Sitemap reveals site structure'
          });
        });
      }
    }

    // Check common hidden pages
    const commonPaths = [
      '/sitemap.xml',
      '/sitemap_index.xml',
      '/admin',
      '/wp-admin',
      '/administrator',
      '/login',
      '/secret',
      '/private',
      '/.git',
      '/.env',
      '/backup',
      '/api',
      '/graphql',
      '/debug'
    ];

    for (const path of commonPaths) {
      try {
        const { stdout } = await execAsync(
          `curl -sI "https://${target}${path}" --max-time 2`,
          { timeout: 3000 }
        );

        if (stdout.includes('200 OK')) {
          pages.push({
            type: 'Hidden page accessible',
            url: `https://${target}${path}`,
            path,
            severity: 'MEDIUM',
            description: 'Page exists but not linked publicly'
          });
        }
      } catch (e) {}
    }

  } catch (e) {}

  return pages;
}

// Detect cloaking
async function detectCloaking(target: string): Promise<boolean> {
  try {
    // Fetch as normal user
    const { stdout: userContent } = await execAsync(
      `curl -sL "https://${target}" -A "Mozilla/5.0" --max-time 5`,
      { timeout: 6000 }
    );

    // Fetch as Googlebot
    const { stdout: botContent } = await execAsync(
      `curl -sL "https://${target}" -A "Googlebot/2.1" --max-time 5`,
      { timeout: 6000 }
    );

    // Compare content length
    const sizeDiff = Math.abs(userContent.length - botContent.length);
    const percentDiff = (sizeDiff / userContent.length) * 100;

    return percentDiff > 20; // More than 20% difference = cloaking

  } catch (e) {
    return false;
  }
}

// Extract meta secrets
async function extractMetaSecrets(target: string): Promise<any[]> {
  const secrets: any[] = [];

  try {
    const { stdout } = await execAsync(
      `curl -sL "https://${target}" --max-time 5`,
      { timeout: 6000 }
    );

    // Extract meta tags
    const metaTags = stdout.match(/<meta[^>]+>/gi) || [];

    metaTags.forEach(tag => {
      // Check for hidden meta refresh redirects
      if (tag.includes('http-equiv="refresh"')) {
        const urlMatch = tag.match(/url=([^"]+)/i);
        if (urlMatch) {
          secrets.push({
            type: 'Hidden Meta Redirect',
            technique: 'Meta Refresh',
            value: urlMatch[1],
            severity: 'HIGH',
            description: 'Automatic redirect hidden in meta tag'
          });
        }
      }

      // Check for keyword stuffing in meta keywords
      if (tag.includes('name="keywords"')) {
        const contentMatch = tag.match(/content="([^"]+)"/i);
        if (contentMatch && contentMatch[1].split(',').length > 20) {
          secrets.push({
            type: 'Keyword Stuffing',
            technique: 'Excessive meta keywords',
            value: contentMatch[1].substring(0, 100) + '...',
            severity: 'MEDIUM',
            description: 'Over 20 keywords - potential spam'
          });
        }
      }

      // Check for hidden descriptions
      if (tag.includes('name="description"')) {
        const contentMatch = tag.match(/content="([^"]+)"/i);
        if (contentMatch) {
          secrets.push({
            type: 'Meta Description',
            value: contentMatch[1],
            severity: 'INFO',
            description: 'SEO meta description'
          });
        }
      }

      // Check for canonical tags
      if (tag.includes('rel="canonical"')) {
        const hrefMatch = tag.match(/href="([^"]+)"/i);
        if (hrefMatch) {
          secrets.push({
            type: 'Canonical URL',
            value: hrefMatch[1],
            severity: 'INFO',
            description: 'Preferred URL for duplicate content'
          });
        }
      }
    });

    // Check for hidden text (CSS display:none or color matching)
    const hiddenTextRegex = /<[^>]+(display\s*:\s*none|visibility\s*:\s*hidden)[^>]*>([^<]+)</gi;
    let match;
    while ((match = hiddenTextRegex.exec(stdout)) !== null) {
      if (match[2] && match[2].length > 10) {
        secrets.push({
          type: 'Hidden Text',
          technique: 'CSS Hidden Content',
          value: match[2].substring(0, 100),
          severity: 'HIGH',
          description: 'Text hidden from users but visible to search engines'
        });
      }
    }

  } catch (e) {}

  return secrets;
}

// Find backlinks using various methods
async function findBacklinks(target: string): Promise<any[]> {
  const backlinks: any[] = [];

  try {
    // Method 1: Check archive.org
    const { stdout: archive } = await execAsync(
      `curl -sL "https://web.archive.org/cdx/search/cdx?url=${target}&output=json&limit=100" --max-time 10`,
      { timeout: 11000 }
    );

    try {
      const archiveData = JSON.parse(archive);
      if (Array.isArray(archiveData) && archiveData.length > 1) {
        backlinks.push({
          source: 'Archive.org',
          count: archiveData.length - 1,
          description: 'Historical snapshots available',
          url: `https://web.archive.org/web/*/${target}`
        });
      }
    } catch (e) {}

  } catch (e) {}

  return backlinks;
}

// Detect black hat techniques
async function detectBlackHat(target: string): Promise<any[]> {
  const techniques: any[] = [];

  try {
    const { stdout } = await execAsync(
      `curl -sL "https://${target}" --max-time 5`,
      { timeout: 6000 }
    );

    // Check for keyword stuffing in page content
    const words = stdout.toLowerCase().match(/\b\w+\b/g) || [];
    const wordCount: any = {};
    words.forEach(word => {
      if (word.length > 3) {
        wordCount[word] = (wordCount[word] || 0) + 1;
      }
    });

    // Find most repeated words
    const sorted = Object.entries(wordCount).sort((a: any, b: any) => b[1] - a[1]) as [string, number][];
    if (sorted.length > 0 && sorted[0][1] > 50) {
      techniques.push({
        type: 'Keyword Stuffing',
        keyword: sorted[0][0],
        count: sorted[0][1],
        severity: 'HIGH',
        description: 'Excessive keyword repetition detected'
      });
    }

    // Check for hidden links (tiny, off-screen, color matching)
    const tinyLinks = stdout.match(/<a[^>]+font-size\s*:\s*0/gi) || [];
    if (tinyLinks.length > 0) {
      techniques.push({
        type: 'Hidden Links',
        count: tinyLinks.length,
        severity: 'CRITICAL',
        description: 'Links hidden with font-size: 0'
      });
    }

    // Check for link farms
    const links = stdout.match(/<a[^>]+href/gi) || [];
    if (links.length > 500) {
      techniques.push({
        type: 'Possible Link Farm',
        count: links.length,
        severity: 'HIGH',
        description: 'Excessive number of outbound links'
      });
    }

    // Check for doorway pages indicators
    if (stdout.includes('doorway') || stdout.includes('gateway')) {
      techniques.push({
        type: 'Doorway Page',
        severity: 'CRITICAL',
        description: 'Possible doorway/gateway page detected'
      });
    }

  } catch (e) {}

  return techniques;
}

// Technical SEO analysis
async function analyzeTechnicalSEO(target: string): Promise<any> {
  const analysis: any = {
    https: false,
    has_sitemap: false,
    has_robots: false,
    page_speed: 'Unknown',
    mobile_friendly: 'Unknown',
    structured_data: false,
    issues: []
  };

  try {
    // Check HTTPS
    try {
      await execAsync(`curl -sI "https://${target}" --max-time 3`, { timeout: 4000 });
      analysis.https = true;
    } catch (e) {
      analysis.https = false;
      analysis.issues.push('No HTTPS - security risk');
    }

    // Check robots.txt
    try {
      const { stdout } = await execAsync(
        `curl -sL "https://${target}/robots.txt" --max-time 3`,
        { timeout: 4000 }
      );
      if (stdout && !stdout.includes('404')) {
        analysis.has_robots = true;
      }
    } catch (e) {}

    // Check sitemap.xml
    try {
      const { stdout } = await execAsync(
        `curl -sI "https://${target}/sitemap.xml" --max-time 3`,
        { timeout: 4000 }
      );
      if (stdout.includes('200 OK')) {
        analysis.has_sitemap = true;
      }
    } catch (e) {}

    // Check page headers
    const { stdout: headers } = await execAsync(
      `curl -sI "https://${target}" --max-time 3`,
      { timeout: 4000 }
    );

    if (!headers.includes('x-frame-options')) {
      analysis.issues.push('Missing X-Frame-Options header');
    }

    if (!headers.includes('strict-transport-security')) {
      analysis.issues.push('Missing HSTS header');
    }

  } catch (e) {}

  return analysis;
}

// Find keyword gaps
async function findKeywordGaps(target: string): Promise<any[]> {
  const gaps: any[] = [];

  try {
    const { stdout } = await execAsync(
      `curl -sL "https://${target}" --max-time 5`,
      { timeout: 6000 }
    );

    // Extract title
    const titleMatch = stdout.match(/<title>([^<]+)<\/title>/i);
    const title = titleMatch ? titleMatch[1] : '';

    // Extract h1
    const h1Match = stdout.match(/<h1[^>]*>([^<]+)<\/h1>/i);
    const h1 = h1Match ? h1Match[1] : '';

    // Check for gaps
    if (!title) {
      gaps.push({
        type: 'Missing Title',
        severity: 'CRITICAL',
        description: 'No title tag found'
      });
    }

    if (!h1) {
      gaps.push({
        type: 'Missing H1',
        severity: 'HIGH',
        description: 'No H1 heading found'
      });
    }

    if (title && h1 && title.toLowerCase() !== h1.toLowerCase()) {
      gaps.push({
        type: 'Title/H1 Mismatch',
        severity: 'MEDIUM',
        description: 'Title and H1 should match for better SEO'
      });
    }

  } catch (e) {}

  return gaps;
}

// Find hidden redirects
async function findHiddenRedirects(target: string): Promise<any[]> {
  const redirects: any[] = [];

  try {
    const { stdout } = await execAsync(
      `curl -sIL "https://${target}" --max-time 5`,
      { timeout: 6000 }
    );

    const locationMatches = stdout.match(/Location:\s*(.+)/gi) || [];
    locationMatches.forEach(match => {
      const url = match.replace(/Location:\s*/i, '').trim();
      redirects.push({
        type: 'HTTP Redirect',
        destination: url,
        severity: 'INFO',
        description: 'Server-side redirect detected'
      });
    });

  } catch (e) {}

  return redirects;
}

// Extract structured data
async function extractStructuredData(target: string): Promise<any[]> {
  const structured: any[] = [];

  try {
    const { stdout } = await execAsync(
      `curl -sL "https://${target}" --max-time 5`,
      { timeout: 6000 }
    );

    // Check for JSON-LD
    const jsonLdMatches = stdout.match(/<script[^>]+type="application\/ld\+json"[^>]*>([^<]+)<\/script>/gi) || [];
    if (jsonLdMatches.length > 0) {
      structured.push({
        type: 'JSON-LD Schema',
        count: jsonLdMatches.length,
        severity: 'INFO',
        description: 'Structured data found for rich snippets'
      });
    }

    // Check for microdata
    if (stdout.includes('itemscope') || stdout.includes('itemprop')) {
      structured.push({
        type: 'Microdata',
        severity: 'INFO',
        description: 'Microdata markup detected'
      });
    }

  } catch (e) {}

  return structured;
}

// Analyze internal linking
async function analyzeInternalLinks(target: string): Promise<any[]> {
  const analysis: any[] = [];

  try {
    const { stdout } = await execAsync(
      `curl -sL "https://${target}" --max-time 5`,
      { timeout: 6000 }
    );

    // Count internal vs external links
    const allLinks = stdout.match(/<a[^>]+href="([^"]+)"/gi) || [];
    let internalCount = 0;
    let externalCount = 0;

    allLinks.forEach(link => {
      const hrefMatch = link.match(/href="([^"]+)"/i);
      if (hrefMatch) {
        const url = hrefMatch[1];
        if (url.startsWith('http') && !url.includes(target)) {
          externalCount++;
        } else {
          internalCount++;
        }
      }
    });

    analysis.push({
      type: 'Link Structure',
      internal_links: internalCount,
      external_links: externalCount,
      ratio: externalCount > 0 ? (internalCount / externalCount).toFixed(2) : 'N/A',
      severity: 'INFO',
      description: 'Internal vs external link analysis'
    });

    if (externalCount > internalCount * 2) {
      analysis.push({
        type: 'Link Balance Issue',
        severity: 'MEDIUM',
        description: 'Too many external links compared to internal'
      });
    }

  } catch (e) {}

  return analysis;
}
